#!/bin/bash
set -euo pipefail

# --- 0. 依存コマンドの確認 ------------------------------------------------------------------
if ! command -v yq &> /dev/null || ! command -v jq &> /dev/null
then
    echo "エラー: yq または jq コマンドが見つかりません。"
    echo "YAML/JSONファイルを処理するためにこれらのツールのインストールが必要です。"
    exit 1
fi

# --- 1. 変数と関数定義 -----------------------------------------------------------

if [ -z "$1" ]; then
    echo "エラー: 設定ファイル (例: config.yaml) を引数に指定してください。"
    exit 1
fi

CONFIG_FILE="$1"
if [ ! -f "$CONFIG_FILE" ]; then
    echo "エラー: 設定ファイル $CONFIG_FILE が見つかりません。"
    exit 1
fi

# 一時ディレクトリを作成し、スクリプト終了時にクリーンアップする
TMP_DIR=$(mktemp -d)
trap 'rm -rf -- "$TMP_DIR"' EXIT

# yq を使って設定値を抽出
GCP_USER=$(yq e '.connection.gcp_user' "$CONFIG_FILE")
GCP_HOST=$(yq e '.connection.gcp_host' "$CONFIG_FILE")
GCP_SSH_PORT=$(yq e '.connection.gcp_ssh_port' "$CONFIG_FILE")
GCP_SSH_KEY_PATH=$(yq e '.connection.gcp_ssh_key_path' "$CONFIG_FILE")
RATHOLE_CONFIG_ROOT=$(yq e '.connection.rathole_config_root' "$CONFIG_FILE")
SYSTEMD_SERVICE_SERVER=$(yq e '.connection.systemd_service_server' "$CONFIG_FILE")
SYSTEMD_SERVICE_CLIENT=$(yq e '.connection.systemd_service_client' "$CONFIG_FILE")

TOKEN=$(yq e '.rathole_global.token' "$CONFIG_FILE")
SERVER_BIND_PORT=$(yq e '.rathole_global.server_bind_port' "$CONFIG_FILE")
HEARTBEAT_TIMEOUT=$(yq e '.rathole_global.heartbeat_timeout' "$CONFIG_FILE")
HEARTBEAT_INTERVAL=$(yq e '.rathole_global.heartbeat_interval' "$CONFIG_FILE")

# サービス配列をJSON形式で抽出
SERVICES_JSON=$(yq e '.services | to_json' "$CONFIG_FILE")
CLIENT_CONFIG_PATH="${RATHOLE_CONFIG_ROOT}/client.toml"
SERVER_CONFIG_PATH="${RATHOLE_CONFIG_ROOT}/server.toml"
CLIENT_TOML_PATH="${TMP_DIR}/client.toml"
SERVER_TOML_PATH="${TMP_DIR}/server.toml"

# --- 2. 設定ファイル生成 ---------------------------------------------------------------------

echo "🚀 rathole設定ファイルの生成を開始します..."

# server.toml の生成ヘッダー
cat > "${SERVER_TOML_PATH}" << EOF
# Generated by rathole-tool/deploy.sh from ${CONFIG_FILE}
[server]
bind_addr = "0.0.0.0:${SERVER_BIND_PORT}"
default_token = "${TOKEN}"
heartbeat_interval = ${HEARTBEAT_INTERVAL}
EOF

# client.toml の生成ヘッダー
cat > "${CLIENT_TOML_PATH}" << EOF
# Generated by rathole-tool/deploy.sh from ${CONFIG_FILE}
[client]
remote_addr = "${GCP_HOST}:${SERVER_BIND_PORT}"
default_token = "${TOKEN}"
heartbeat_timeout = ${HEARTBEAT_TIMEOUT}
EOF

# サービスごとの設定をループで追加し、UFW許可ポートリストを作成
UFW_PUBLIC_PORTS=""
echo "$SERVICES_JSON" | jq -c '.[]' | while read i; do
    SERVICE_NAME_BASE=$(echo "$i" | jq -r '.name')
    LOCAL_ADDR=$(echo "$i" | jq -r '.local_addr')
    PUBLIC_PORT=$(echo "$i" | jq -r '.public_port')
    PROTOCOL_SET=$(echo "$i" | jq -r '.protocol')

    PROTOCOLS=()
    if [ "$PROTOCOL_SET" == "tcp" ]; then
        PROTOCOLS=("tcp")
    elif [ "$PROTOCOL_SET" == "udp" ]; then
        PROTOCOLS=("udp")
    elif [ "$PROTOCOL_SET" == "tcp/udp" ]; then
        PROTOCOLS=("tcp" "udp")
    else
        echo "警告: サービス ${SERVICE_NAME_BASE} の protocol が無効です (${PROTOCOL_SET})。tcpとして扱います。"
        PROTOCOLS=("tcp")
    fi

    for PROTOCOL in "${PROTOCOLS[@]}"; do
        SERVICE_NAME="${SERVICE_NAME_BASE}_${PROTOCOL}"
        
        # UFW許可ポートリストに追加 (ポート:プロトコル)
        UFW_PUBLIC_PORTS="${UFW_PUBLIC_PORTS} ${PUBLIC_PORT}/${PROTOCOL}"

        # server.toml にサービス設定を追加
cat >> "${SERVER_TOML_PATH}" << EOF

[server.services.${SERVICE_NAME}]
type = "${PROTOCOL}"
bind_addr = "0.0.0.0:${PUBLIC_PORT}"
EOF

        # client.toml にサービス設定を追加
cat >> "${CLIENT_TOML_PATH}" << EOF

[client.services.${SERVICE_NAME}]
type = "${PROTOCOL}"
local_addr = "${LOCAL_ADDR}"
EOF

    done # PROTOCOLS loop
done

echo "✅ server.toml と client.toml を生成しました。"

# --- 3. 自宅サーバーへの設定ファイル配置 ----------------------------------------------------
echo "🏠 自宅サーバーに client.toml を配置します..."
sudo mkdir -p "$(dirname "${CLIENT_CONFIG_PATH}")"
cat "${CLIENT_TOML_PATH}" | sudo tee "${CLIENT_CONFIG_PATH}" > /dev/null
sudo chmod 644 "${CLIENT_CONFIG_PATH}"
echo "✅ client.toml を ${CLIENT_CONFIG_PATH} に配置しました。"


# --- 4. GCPサーバーへの転送、UFW設定、リモート実行 ----------------------------------------------

echo "📤 server.toml を GCPサーバー (${GCP_HOST}) へ転送し、設定を適用します..."

# server.toml をGCPサーバーの一時ディレクトリへ転送
TMP_REMOTE_PATH="/tmp/server.toml"
scp -P "${GCP_SSH_PORT}" -i "${GCP_SSH_KEY_PATH}" "${SERVER_TOML_PATH}" ${GCP_USER}@${GCP_HOST}:"${TMP_REMOTE_PATH}"

echo "✅ server.toml の転送が完了しました。"
echo "🔒 GCPサーバー上の UFW と rathole サービスを設定します..."

# GCPサーバーへSSH接続し、UFW設定とrathole再起動を実行
ssh -p "${GCP_SSH_PORT}" -i "${GCP_SSH_KEY_PATH}" ${GCP_USER}@${GCP_HOST} <<-EOF
    set -eu
    # 0. 設定ファイルを正しい場所へ移動
    echo '設定ファイルを所定の場所へ移動します...'
    sudo mkdir -p "$(dirname "${SERVER_CONFIG_PATH}")"
    sudo mv "${TMP_REMOTE_PATH}" "${SERVER_CONFIG_PATH}"
    sudo chown root:root "${SERVER_CONFIG_PATH}"
    sudo chmod 644 "${SERVER_CONFIG_PATH}"
    echo "✅ 設定ファイルを ${SERVER_CONFIG_PATH} へ移動し、権限を設定しました。"

    # 1. UFW設定
    # `ufw` コマンドは sudo がないと PATH が通っていない場合があるため、
    # `sudo ufw status` が成功するかどうかで存在を判断する
    if ! sudo ufw status &> /dev/null; then
        echo '警告: UFWがインストールされていないか、sudoで実行できません。インストールを推奨します (sudo apt install ufw)。'
        echo 'UFW設定ステップをスキップします。'
    else
        echo 'UFW: 基本ルール (デフォルト拒否, SSH許可) を設定'
        sudo ufw default deny incoming
        sudo ufw default allow outgoing
        sudo ufw allow ${GCP_SSH_PORT}/tcp comment 'Allow SSH'

        echo 'UFW: rathole クライアント接続ポート (${SERVER_BIND_PORT}/tcp) を許可'
        sudo ufw allow ${SERVER_BIND_PORT}/tcp comment 'rathole client listen port'

        echo 'UFW: 公開サービスポートを許可 (TCP/UDP)'
        # 重複するポート:プロトコルの組み合わせをユニークにして処理
        for port_proto in \$(echo '${UFW_PUBLIC_PORTS}' | xargs -n1 | sort -u); do
            sudo ufw allow \$port_proto comment 'rathole exposed service'
        done

        echo 'UFW: 有効化 (既に有効な場合は無視されます)'
        sudo ufw --force enable
        sudo ufw status verbose
    fi

    # 2. rathole サービスを再起動
    echo 'rathole: サービス再起動'
    sudo systemctl restart ${SYSTEMD_SERVICE_SERVER}
EOF

echo "✅ GCPサーバー上の設定が完了し、ratholeが新しい設定で再起動されました。"

# --- 5. 自宅サーバー側 rathole 実行 ----------------------------------------------------------

echo "🏠 自宅サーバー側で rathole クライアントを起動します..."

sudo systemctl restart ${SYSTEMD_SERVICE_CLIENT}